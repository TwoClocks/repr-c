use repr_c::layout::{BuiltinType, RecordKind, TypeLayout, FieldLayout};
use crate::ast::{
    Type, TypeVariant, Declaration, Record, RecordField, Array, Expr,
    UnaryExprType, BinaryExprType, TypeExprType, Annotation, OpaqueTypeLayout, ExprType, BuiltinExpr,
    DeclarationType, OffsetofType, IndexType, Index, Span, State,
};
use crate::result::{CustomError};
use std::str::FromStr;
use lalrpop_util::ParseError;

grammar<'a>(state: &'a mut State);

match {
    r"//[^\n\r]*[\n\r]*" => { },
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
} else {
    r"\s*" => { },
    _,
}

extern {
    type Error = CustomError;
}

pub(crate) Top = <(<Declaration>)+>;

Declaration: Declaration = <d:DeclarationType> => Declaration {
        span: Span(d.0, d.1),
        name: d.2,
        ty: d.3
    };

DeclarationType: (usize, usize, String, DeclarationType) = {
    <l:@L> <name:id> <r:@R> "=" <ty:Type> => (l, r, name, DeclarationType::Type(ty)),
    "const" <l:@L> <name:id> <r:@R> "=" <e:TopLevelExpr> => (l, r, name, DeclarationType::Const(e)),
};

Type: Type =
        <lo:@L>
        <layout:TypeLayout?>
        <layout_hi:@R>
        <annotations:Annotation*>
        <mut variant:TypeVariant>
    => {
        let id = state.next_id;
        state.next_id += 1;
        if let TypeVariant::Record(r) = &mut variant {
            for (pos, f) in r.fields.iter_mut().enumerate() {
                f.parent_id = id;
                f.pos = pos;
            }
        }
        Type {
            id,
            lo,
            layout,
            layout_hi,
            annotations,
            variant,
        }
    };

TypeLayout: TypeLayout =
        <lo:@L> "{" <c:Comma<LayoutComponent>> "}" <hi:@R> =>? {
            h!(c, "size", "alignment", "required");
            Ok(TypeLayout {
                size_bits: g!(c, "size", lo, hi),
                alignment_bits: g!(c, "alignment", lo, hi),
                required_alignment_bits: g!(c, "required", lo, hi, Some(8)),
            })
         };

FieldLayout: FieldLayout =
        <lo:@L> "{" <c:Comma<LayoutComponent>> "}" <hi:@R> =>? {
            h!(c, "offset", "size");
            Ok(FieldLayout {
                offset_bits: g!(c, "offset", lo, hi),
                size_bits: g!(c, "size", lo, hi),
            })
         };

LayoutComponent = Component<u64>;

Component<T>: (String, T, Span) = {
    <lo:@L> <c:id> <hi:@L> ":" <n:T> => (c, n, Span(lo, hi)),
};

OpaqueTypeLayout: OpaqueTypeLayout =
        <lo:@L> "{" <c:Comma<OpaqueLayoutComponent>> "}" <hi:@R> =>? {
            h!(c, "size", "alignment", "required");
            Ok(OpaqueTypeLayout {
                size_bits: Box::new(g!(c, "size", lo, hi)),
                alignment_bits: Box::new(g!(c, "alignment", lo, hi)),
                required_alignment_bits: Box::new(g!(c, "required", lo, hi, Some(Expr { span: Span(lo, hi), value: Some(8), value_hi: hi, ty: ExprType::Lit(8) }))),
            })
         };

OpaqueLayoutComponent: (String, Expr, Span) = {
    <lo:@L> <c:id> <hi:@L> ":" <n:Expr> => (c, n, Span(lo, hi)),
};

Annotation: Annotation = {
    "@" "pragma_pack" "(" <n:TopLevelExpr> ")" => Annotation::PragmaPack(Box::new(n)),
    "@" "attr_packed" => Annotation::AttrPacked,
    "@" "align" "(" <n:TopLevelExpr> ")" => Annotation::Aligned(Box::new(n)),
};

TypeVariant: TypeVariant = {
    <b:BuiltinType> => TypeVariant::Builtin(b),
    <kind:RecordKind> "{" <fields:Comma<RecordField>> "}" => TypeVariant::Record(Record {
        kind,
        fields,
    }),
    "[" <n:TopLevelExpr?> "]" <t:Type> => TypeVariant::Array(Array {
        element_type: Box::new(t),
        num_elements: n.map(Box::new),
    }),
    "typedef" <t:Type> => TypeVariant::Typedef(Box::new(t)),
    "opaque" <l:OpaqueTypeLayout> => TypeVariant::Opaque(l),
    "enum" "{" <Comma<TopLevelExpr>> "}" => TypeVariant::Enum(<>),
    <l:@L> <n:id> <r:@R> => TypeVariant::Name(n, Span(l, r)),
};

RecordKind: RecordKind = {
    "struct" => RecordKind::Struct,
    "union" => RecordKind::Union,
};

RecordField: RecordField =
        <lo:@L>
        <layout:FieldLayout?>
        <layout_hi:@R>
        <annotations:(<Annotation>)*>
        <name:RecordFieldName>
        <ty:Type>
        <bit_width:(":" <TopLevelExpr>)?>
    =>
    RecordField {
        pos: 0,
        parent_id: 0,
        lo,
        layout,
        layout_hi,
        annotations,
        name,
        ty,
        bit_width: bit_width.map(Box::new),
    };

RecordFieldName: Option<String> = {
    "_" => None,
    <n:id> => Some(n),
};

Comma<T>: Vec<T> = <head:(<T> ",")*><tail:T?> => head.into_iter().chain(tail.into_iter()).collect();

BuiltinType: BuiltinType = {
    "()" => BuiltinType::Unit,
    "bool" => BuiltinType::Bool,
    "u8" => BuiltinType::U8,
    "u16" => BuiltinType::U16,
    "u32" => BuiltinType::U32,
    "u64" => BuiltinType::U64,
    "u128" => BuiltinType::U128,
    "i8" => BuiltinType::I8,
    "i16" => BuiltinType::I16,
    "i32" => BuiltinType::I32,
    "i64" => BuiltinType::I64,
    "i128" => BuiltinType::I128,
    "char" => BuiltinType::Char,
    "signed" "char" => BuiltinType::SignedChar,
    "unsigned" "char" => BuiltinType::UnsignedChar,
    "signed"? "short" => BuiltinType::Short,
    "unsigned" "short" => BuiltinType::UnsignedShort,
    "signed"? "int" => BuiltinType::Int,
    "unsigned" "int"? => BuiltinType::UnsignedInt,
    "signed"? "long" => BuiltinType::Long,
    "unsigned" "long" => BuiltinType::UnsignedLong,
    "signed"? "long" "long" => BuiltinType::LongLong,
    "unsigned" "long" "long" => BuiltinType::UnsignedLongLong,
    "f32" => BuiltinType::F32,
    "f64" => BuiltinType::F64,
    "float" => BuiltinType::Float,
    "double" => BuiltinType::Double,
    "ptr" => BuiltinType::Pointer,
};

u64: u64 = <lo:@L> <s:r"[0-9]+"> <hi:@R> =>? u64::from_str(s).map_err(|_| ParseError::User {
    error: CustomError {
        span: Span(lo, hi),
        msg: format!("Out of bounds integer for u64"),
    }
});

i128: i128 = <lo:@L> <s:r"[0-9]+"> <hi:@R> =>? i128::from_str(s).map_err(|_| ParseError::User {
    error: CustomError {
        span: Span(lo, hi),
        msg: format!("Out of bounds integer for i128"),
    }
});

id: String = <s:r"[a-zA-Z_][a-zA-Z_0-9]*"> => s.to_string();

TopLevelExpr: Expr = <lo:@L> <v:ExprValue?> <value_hi:@R> <mut e:Expr> => {
    if v.is_some() {
        e.value = v;
    } else if let ExprType::Lit(v) = e.ty {
        e.value = Some(v);
    }
    e.span.0 = lo;
    e.value_hi = value_hi;
    e
};

ExprValue: i128 = "{" <i128> "}";

Expr: Expr = <SpannedExpr<OrExpr>>;

SpannedExpr<T>: Expr =
    <lo:@L> <ty:T> <hi:@R> => Expr { span: Span(lo, hi), value: None, value_hi: lo, ty };

BinaryExpr<E, S>: ExprType = {
    <E>,
    <l:SpannedExpr<BinaryExpr<E, S>>> <s:S> <r:SpannedExpr<E>> => ExprType::Binary(s, Box::new(l), Box::new(r)),
};

OrExpr = <BinaryExpr<AndExpr, OrExprType>>;

OrExprType: BinaryExprType = "||" => BinaryExprType::LogicalOr;

AndExpr = <BinaryExpr<RelExpr, AndExprType>>;

AndExprType: BinaryExprType = "&&" => BinaryExprType::LogicalAnd;

RelExpr = <BinaryExpr<SumExpr, RelExprType>>;

RelExprType: BinaryExprType = {
    "==" => BinaryExprType::Eq,
    "!=" => BinaryExprType::NotEq,
    "<=" => BinaryExprType::Le,
    ">=" => BinaryExprType::Ge,
    "<" => BinaryExprType::Lt,
    ">" => BinaryExprType::Gt,
};

SumExpr = <BinaryExpr<MulExpr, SumExprType>>;

SumExprType: BinaryExprType = {
    "+" => BinaryExprType::Add,
    "-" => BinaryExprType::Sub,
};

MulExpr = <BinaryExpr<UnaryExpr, MulExprType>>;

MulExprType: BinaryExprType = {
    "*" => BinaryExprType::Mul,
    "/" => BinaryExprType::Div,
    "%" => BinaryExprType::Mod,
};

UnaryExpr: ExprType = {
    <ExprTerminal>,
    <k:UnaryExprType> <r:SpannedExpr<UnaryExpr>> => ExprType::Unary(k, Box::new(r)),
};

UnaryExprType: UnaryExprType = {
    "!" => UnaryExprType::Not,
    "-" => UnaryExprType::Neg,
};

ExprTerminal: ExprType = {
    "(" <e:Expr> ")" => e.ty,
    <BuiltinExpr> => ExprType::Builtin(<>),
    <i128> => ExprType::Lit(<>),
    <e:TypeExprType> "(" <t:Type> ")" => ExprType::TypeExpr(e, Box::new(t)),
    <e:OffsetofType> "(" <t:Type> "," <p:OffsetofPath> ")" => ExprType::Offsetof(e, t, p),
    <id> => ExprType::Name(<>),
};

BuiltinExpr: BuiltinExpr = {
    "BITS_PER_BYTE" => BuiltinExpr::BitsPerByte,
};

TypeExprType: TypeExprType = {
    "sizeof" => TypeExprType::Sizeof,
    "alignof" => TypeExprType::Alignof,
};

OffsetofType: OffsetofType = {
    "offsetof" => OffsetofType::Bytes,
    "offsetof_bits" => OffsetofType::Bits,
};

OffsetofPath: Vec<Index> = {
    <Index<ArrayIndex>> => vec!(<>),
    <Index<FieldIndex>> => vec!(<>),
    <mut p:OffsetofPath> <n:Index<ArrayIndex>> => {
        p.push(n);
        p
    },
    <mut p:OffsetofPath> "." <n:Index<FieldIndex>> => {
        p.push(n);
        p
    },
};

Index<T>: Index = <lo:@L> <ty:T> <hi:@R> => Index { span: Span(lo, hi), ty };

ArrayIndex: IndexType = "[" <e:TopLevelExpr> "]" => IndexType::Array(Box::new(e));

FieldIndex: IndexType = <id> => IndexType::Field(<>);
