use repr_c::layout::{BuiltinType, RecordKind, TypeLayout, FieldLayout};
use crate::ast::{
    Type, TypeVariant, Declaration, Record, RecordField, Array, Expr,
    UnaryExprType, BinaryExprType, TypeExprType, Annotation, OpaqueTypeLayout, ExprType, BuiltinExpr,
    DeclarationType, OffsetofType, IndexType, Index, Span, State,
};
use crate::result::{CustomError};
use std::collections::HashMap;
use crate::parser_util::{parse_type_layout, components_to_hashmap, parse_field_layout, parse_number};

grammar<'a>(state: &'a mut State);

match {
    r"//[^\n\r]*[\n\r]*" => { },
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
} else {
    r"\s*" => { },
    _,
}

extern {
    type Error = CustomError;
}

pub(crate) Top = <(<Declaration>)+>;

Declaration: Declaration = <d:DeclarationType> => Declaration {
        span: Span(d.0, d.1),
        name: d.2,
        ty: d.3
    };

DeclarationType: (usize, usize, String, DeclarationType) = {
    <l:@L> <name:id> <r:@R> "=" <ty:Type> => (l, r, name, DeclarationType::Type(ty)),
    "const" <l:@L> <name:id> <r:@R> "=" <e:TopLevelExpr> => (l, r, name, DeclarationType::Const(e)),
};

Type: Type =
        <lo:@L>
        <layout:TypeLayout?>
        <layout_hi:@R>
        <annotations:Annotation*>
        <mut variant:TypeVariant>
    => {
        let id = state.next_id;
        state.next_id += 1;
        if let TypeVariant::Record(r) = &mut variant {
            let mut pos = 0;
            for f in &mut r.fields {
                f.parent_id = id;
                if f.name.is_some() {
                    f.pos = Some(pos);
                    pos += 1;
                }
            }
        }
        Type {
            id,
            lo,
            layout,
            layout_hi,
            annotations,
            variant,
        }
    };

TypeLayout: TypeLayout = <lo:@L> "{" <c:Components<u64>> "}" <hi:@R> =>? {
    let [size, field, pointer, required] = parse_type_layout(&c, Span(lo, hi), 8)?;
    Ok(TypeLayout {
        size_bits: size,
        field_alignment_bits: field,
        pointer_alignment_bits: pointer,
        required_alignment_bits: required,
    })
};

OpaqueTypeLayout: OpaqueTypeLayout =
        <lo:@L> "{" <c:Components<Expr>> "}" <hi:@R> =>? {
            let def = Expr { span: Span(lo, hi), value: Some(8), value_hi: hi, ty: ExprType::Lit(8) };
            let [size, field, pointer, required] = parse_type_layout(&c, Span(lo, hi), def)?;
            Ok(OpaqueTypeLayout {
                size_bits: Box::new(size),
                field_alignment_bits: Box::new(field),
                pointer_alignment_bits: Box::new(pointer),
                required_alignment_bits: Box::new(required),
            })
         };

FieldLayout: FieldLayout =
        <lo:@L> "{" <c:Components<u64>> "}" <hi:@R> =>? parse_field_layout(&c, Span(lo, hi));

Components<T>: HashMap<String, (T, Span)> = <c:Comma<Component<T>>> =>?
            components_to_hashmap(c);

Component<T>: (String, T, Span) = {
    <lo:@L> <c:id> <hi:@L> ":" <n:T> => (c, n, Span(lo, hi)),
};

Annotation: Annotation = {
    "@" "pragma_pack" "(" <n:TopLevelExpr> ")" => Annotation::PragmaPack(Box::new(n)),
    "@" "attr_packed" => Annotation::AttrPacked,
    "@" "align" "(" <n:TopLevelExpr> ")" => Annotation::Aligned(Box::new(n)),
};

TypeVariant: TypeVariant = {
    <b:BuiltinType> => TypeVariant::Builtin(b),
    <kind:RecordKind> "{" <fields:Comma<RecordField>> "}" => TypeVariant::Record(Record {
        kind,
        fields,
    }),
    "[" <n:TopLevelExpr?> "]" <t:Type> => TypeVariant::Array(Array {
        element_type: Box::new(t),
        num_elements: n.map(Box::new),
    }),
    "typedef" <t:Type> => TypeVariant::Typedef(Box::new(t)),
    "opaque" <l:OpaqueTypeLayout> => TypeVariant::Opaque(l),
    "enum" "{" <Comma<TopLevelExpr>> "}" => TypeVariant::Enum(<>),
    <l:@L> <n:id> <r:@R> => TypeVariant::Name(n, Span(l, r)),
};

RecordKind: RecordKind = {
    "struct" => RecordKind::Struct,
    "union" => RecordKind::Union,
};

RecordField: RecordField =
        <lo:@L>
        <layout:FieldLayout?>
        <layout_hi:@R>
        <annotations:(<Annotation>)*>
        <name:RecordFieldName>
        <ty:Type>
        <bit_width:(":" <TopLevelExpr>)?>
    =>
    RecordField {
        pos: None,
        parent_id: 0,
        lo,
        layout,
        layout_hi,
        annotations,
        name,
        ty,
        bit_width: bit_width.map(Box::new),
    };

RecordFieldName: Option<String> = {
    "_" => None,
    <n:id> => Some(n),
};

Comma<T>: Vec<T> = <head:(<T> ",")*><tail:T?> => head.into_iter().chain(tail.into_iter()).collect();

BuiltinType: BuiltinType = {
    "()" => BuiltinType::Unit,
    "bool" => BuiltinType::Bool,
    "u8" => BuiltinType::U8,
    "u16" => BuiltinType::U16,
    "u32" => BuiltinType::U32,
    "u64" => BuiltinType::U64,
    "u128" => BuiltinType::U128,
    "i8" => BuiltinType::I8,
    "i16" => BuiltinType::I16,
    "i32" => BuiltinType::I32,
    "i64" => BuiltinType::I64,
    "i128" => BuiltinType::I128,
    "char" => BuiltinType::Char,
    "signed" "char" => BuiltinType::SignedChar,
    "unsigned" "char" => BuiltinType::UnsignedChar,
    "signed"? "short" => BuiltinType::Short,
    "unsigned" "short" => BuiltinType::UnsignedShort,
    "signed"? "int" => BuiltinType::Int,
    "unsigned" "int"? => BuiltinType::UnsignedInt,
    "signed"? "long" => BuiltinType::Long,
    "unsigned" "long" => BuiltinType::UnsignedLong,
    "signed"? "long" "long" => BuiltinType::LongLong,
    "unsigned" "long" "long" => BuiltinType::UnsignedLongLong,
    "f32" => BuiltinType::F32,
    "f64" => BuiltinType::F64,
    "float" => BuiltinType::Float,
    "double" => BuiltinType::Double,
    "ptr" => BuiltinType::Pointer,
};

u64: u64 = <lo:@L> <s:number> <hi:@R> =>? parse_number(s, Span(lo, hi));

i128: i128 = <lo:@L> <s:number> <hi:@R> =>? parse_number(s, Span(lo, hi));

number: &'input str = <r"(0x[0-9a-fA-F_]+|[0-9]+|0o[0-7]+|0b[01]+)">;

id: String = <s:r"[a-zA-Z_][a-zA-Z_0-9]*"> => s.to_string();

TopLevelExpr: Expr = <lo:@L> <v:ExprValue?> <value_hi:@R> <mut e:Expr> => {
    if v.is_some() {
        e.value = v;
    } else if let ExprType::Lit(v) = e.ty {
        e.value = Some(v);
    }
    e.span.0 = lo;
    e.value_hi = value_hi;
    e
};

ExprValue: i128 = "{" <i128> "}";

Expr: Expr = <SpannedExpr<OrExpr>>;

SpannedExpr<T>: Expr =
    <lo:@L> <ty:T> <hi:@R> => Expr { span: Span(lo, hi), value: None, value_hi: lo, ty };

BinaryExpr<E, S>: ExprType = {
    <E>,
    <l:SpannedExpr<BinaryExpr<E, S>>> <s:S> <r:SpannedExpr<E>> => ExprType::Binary(s, Box::new(l), Box::new(r)),
};

OrExpr = <BinaryExpr<AndExpr, OrExprType>>;

OrExprType: BinaryExprType = "||" => BinaryExprType::LogicalOr;

AndExpr = <BinaryExpr<RelExpr, AndExprType>>;

AndExprType: BinaryExprType = "&&" => BinaryExprType::LogicalAnd;

RelExpr = <BinaryExpr<SumExpr, RelExprType>>;

RelExprType: BinaryExprType = {
    "==" => BinaryExprType::Eq,
    "!=" => BinaryExprType::NotEq,
    "<=" => BinaryExprType::Le,
    ">=" => BinaryExprType::Ge,
    "<" => BinaryExprType::Lt,
    ">" => BinaryExprType::Gt,
};

SumExpr = <BinaryExpr<MulExpr, SumExprType>>;

SumExprType: BinaryExprType = {
    "+" => BinaryExprType::Add,
    "-" => BinaryExprType::Sub,
};

MulExpr = <BinaryExpr<UnaryExpr, MulExprType>>;

MulExprType: BinaryExprType = {
    "*" => BinaryExprType::Mul,
    "/" => BinaryExprType::Div,
    "%" => BinaryExprType::Mod,
};

UnaryExpr: ExprType = {
    <ExprTerminal>,
    <k:UnaryExprType> <r:SpannedExpr<UnaryExpr>> => ExprType::Unary(k, Box::new(r)),
};

UnaryExprType: UnaryExprType = {
    "!" => UnaryExprType::Not,
    "-" => UnaryExprType::Neg,
};

ExprTerminal: ExprType = {
    "(" <e:Expr> ")" => e.ty,
    <BuiltinExpr> => ExprType::Builtin(<>),
    <i128> => ExprType::Lit(<>),
    <e:TypeExprType> "(" <t:Type> ")" => ExprType::TypeExpr(e, Box::new(t)),
    <e:OffsetofType> "(" <t:Type> "," <p:OffsetofPath> ")" => ExprType::Offsetof(e, t, p),
    <id> => ExprType::Name(<>),
};

BuiltinExpr: BuiltinExpr = {
    "BITS_PER_BYTE" => BuiltinExpr::BitsPerByte,
};

TypeExprType: TypeExprType = {
    "sizeof" => TypeExprType::Sizeof,
    "alignof" => TypeExprType::Alignof,
};

OffsetofType: OffsetofType = {
    "offsetof" => OffsetofType::Bytes,
    "offsetof_bits" => OffsetofType::Bits,
};

OffsetofPath: Vec<Index> = {
    <Index<ArrayIndex>> => vec!(<>),
    <Index<FieldIndex>> => vec!(<>),
    <mut p:OffsetofPath> <n:Index<ArrayIndex>> => {
        p.push(n);
        p
    },
    <mut p:OffsetofPath> "." <n:Index<FieldIndex>> => {
        p.push(n);
        p
    },
};

Index<T>: Index = <lo:@L> <ty:T> <hi:@R> => Index { span: Span(lo, hi), ty };

ArrayIndex: IndexType = "[" <e:TopLevelExpr> "]" => IndexType::Array(Box::new(e));

FieldIndex: IndexType = <id> => IndexType::Field(<>);
